function net = cnn_cifar_init_alexnet(opts,Portion)

lr = [.1 2] ;

net.layers = {} ;

% Block 1
net.layers{end+1} = struct('type', 'conv', ...
                           'weights', {{0.005*randn(5,5,3,96, 'single'), zeros(1, 96, 'single')}}, ...
                           'sparseMaps', generateSparseMaps(5,5,3,96,Portion,'uniform'),...
                           'learningRate', lr, ...
                           'stride', 1, ...
                           'pad', 2) ;

net.layers{end+1} = struct('type', 'relu') ;

% Block 2
net.layers{end+1} = struct('type', 'conv', ...
                           'weights', {{0.005*randn(5,5,96,256, 'single'), zeros(1,256,'single')}}, ...
                           'sparseMaps', generateSparseMaps(5,5,96,256,Portion,'uniform'),...
                           'learningRate', lr, ...
                           'stride', 1, ...
                           'pad', 2) ;
net.layers{end+1} = struct('type', 'relu') ;

net.layers{end+1} = struct('type', 'pool', ...
                           'method', 'max', ...
                           'pool', [3 3], ...
                           'stride', 2, ...
                           'pad', [0 1 0 1]) ; % Emulate caffe
net.layers{end+1} = struct('type', 'conv', ...
                           'weights', {{0.005*randn(3,3,256,384, 'single'), zeros(1,384,'single')}}, ...
                           'sparseMaps', generateSparseMaps(3,3,256,384,Portion,'uniform'),...
                           'learningRate', lr, ...
                           'stride', 1, ...
                           'pad', 1) ;
net.layers{end+1} = struct('type', 'relu') ;

net.layers{end+1} = struct('type', 'pool', ...
                           'method', 'max', ...
                           'pool', [3 3], ...
                           'stride', 2, ...
                           'pad', [0 1 0 1]) ; % Emulate caffe

% Block 4.1
net.layers{end+1} = struct('type', 'conv', ...
                           'weights', {{0.005*randn(3,3,384,384, 'single'), zeros(1,384,'single')}}, ...
                           'sparseMaps', generateSparseMaps(3,3,384,384,Portion,'uniform'),...
                           'learningRate', lr, ...
                           'stride', 1, ...
                           'pad', 1) ;
net.layers{end+1} = struct('type', 'relu') ;

net.layers{end+1} = struct('type', 'conv', ...
                           'weights', {{0.005*randn(3,3,384,256, 'single'), zeros(1,256,'single')}}, ...
                           'sparseMaps', generateSparseMaps(3,3,384,256,Portion,'uniform'),...
                           'learningRate', lr, ...
                           'stride', 1, ...
                           'pad', 1) ;
net.layers{end+1} = struct('type', 'relu') ;
% Block 5

net.layers{end+1} = struct('type', 'pool', ...
                           'method', 'max', ...
                           'pool', [3 3], ...
                           'stride', 2, ...
                           'pad', [0 1 0 1]) ; % Emulate caffe
                       
net.layers{end+1} = struct('type', 'conv', ...
                           'weights', {{0.005*randn(4,4,256,128, 'single'), zeros(1,128,'single')}}, ...
                           'sparseMaps', generateSparseMaps(4,4,256,128,Portion,'uniform'),...
                           'learningRate', lr, ...
                           'stride', 1, ...
                           'pad', 0) ;
net.layers{end+1} = struct('type', 'relu') ;  
net.layers{end+1} = struct('type', 'conv', ...
                           'weights', {{0.05*randn(1,1,128,64, 'single'), zeros(1,64,'single')}}, ...
                           'sparseMaps', generateSparseMaps(1,1,128,64,Portion,'uniform'),...
                           'learningRate', lr, ...
                           'stride', 1, ...
                           'pad', 0) ;
net.layers{end+1} = struct('type', 'relu') ;   
net.layers{end+1} = struct('type', 'conv', ...
                           'weights', {{0.05*randn(1,1,64,10, 'single'), zeros(1,10,'single')}}, ...
                           'sparseMaps', ones(1,1,64,10),...
                           'learningRate', .1*lr, ...
                           'stride', 1, ...
                           'pad', 0) ;

% Loss layer
net.layers{end+1} = struct('type', 'softmaxloss') ;

function sparseMaps = generateSparseMaps(H,W,D,N,Percen,type)
    sparseMaps = zeros(H,W,D,N);
   if nargin <= 5
       type = 'full';
   end
    switch type
         case 'full'
            tmp  = ones(H,W,1,N);
        case 'uniform'
            tmp  = rand(H,W,1,N);
            tmp = tmp > (1-Percen);
        case 'gauss'
            Gauss = fspecial('gaussian',[H W], H/3 );
            Gauss = Gauss./Gauss(ceil(H/2),ceil(W/2));
            tmp  = rand(H,W,1,N).*repmat(Gauss, [1 1 1 N]);
            tmp = tmp > (1-Percen);
        case 'detSparse'
            tmp1 = zeros(H, W);
            tmp1(3,3:3) = 1;
            tmp = repmat(tmp1,[1,1,1,N]);

        otherwise
            tmp  = rand(H,W,1,N);
            tmp = tmp > (1-Percen);
    end
%     tmp = tmp < 1;
    sparseMaps = single(repmat(tmp,[1,1,D,1]));
   